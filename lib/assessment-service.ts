import type { AssessmentAnswer, AssessmentResult } from "@/types/assessment"
import { assessmentCategories } from "@/data/assessment-questions"
import type { SupabaseClient } from "@supabase/supabase-js"

export class AssessmentService {
  private static activeRequests = new Map<string, AbortController>()

  static get assessmentCategories() {
    return assessmentCategories
  }

  static getCategory(categoryId: string) {
    return assessmentCategories.find((cat) => cat.id === categoryId)
  }

  static async analyzeWithAI(categoryId: string, answers: AssessmentAnswer[]): Promise<{ data: any; error: any }> {
    try {
      const category = AssessmentService.getCategory(categoryId)
      if (!category) {
        throw new Error("Category not found")
      }

      const enrichedAnswers = answers.map((answer) => {
        const question = category.questions.find((q) => q.id === answer.questionId)
        return {
          ...answer,
          question: question?.question || "‡πÑ‡∏°‡πà‡∏£‡∏∞‡∏ö‡∏∏‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°",
        }
      })

      const response = await fetch("/api/assessment/analyze", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          categoryId,
          categoryTitle: category.title,
          answers: enrichedAnswers,
        }),
      })

      if (!response.ok) {
        const errorData = await response.json()
        throw new Error(errorData.error || "Failed to analyze assessment")
      }

      const result = await response.json()
      return { data: result.analysis, error: null }
    } catch (error) {
      return { data: null, error }
    }
  }

  static async saveAssessment(
    supabaseClient: SupabaseClient,
    userId: string,
    categoryId: string,
    categoryTitle: string,
    answers: AssessmentAnswer[],
    aiAnalysis?: any,
  ): Promise<{ data: any; error: any }> {
    console.log("üíæ AssessmentService: Starting save assessment process...")

    try {
      if (!userId) {
        throw new Error("User not authenticated")
      }

      if (!Array.isArray(answers) || answers.length === 0) {
        throw new Error("Invalid answers array")
      }

      if (!supabaseClient) {
        throw new Error("Database connection not available")
      }

      // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå
      let result: AssessmentResult
      if (categoryId === "basic") {
        result = this.calculateBasicAssessmentResult(answers)
      } else if (aiAnalysis) {
        result = {
          categoryId,
          totalScore: aiAnalysis.score,
          maxScore: 100,
          percentage: aiAnalysis.score,
          riskLevel: aiAnalysis.riskLevel,
          riskFactors: aiAnalysis.riskFactors || [],
          recommendations: aiAnalysis.recommendations || [],
        }
      } else {
        throw new Error("AI analysis required for non-basic assessments")
      }

      // ‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å
      const assessmentData = {
        user_id: userId,
        category_id: categoryId,
        category_title: categoryTitle,
        answers: answers,
        total_score: Math.round(result.totalScore),
        max_score: Math.round(result.maxScore),
        percentage: Math.round(result.percentage),
        risk_level: result.riskLevel,
        risk_factors: result.riskFactors || [],
        recommendations: result.recommendations || [],
        completed_at: new Date().toISOString(),
      }

      console.log("üíæ AssessmentService: Inserting assessment data to Supabase...")
      const { data: insertedData, error } = await supabaseClient
        .from("assessments")
        .insert(assessmentData)
        .select()
        .single()

      if (error) {
        console.error("‚ùå AssessmentService: Supabase insert error:", error)
        throw new Error(`Database error: ${error.message}`)
      }

      if (!insertedData) {
        throw new Error("No data returned from insert operation")
      }

      console.log("‚úÖ AssessmentService: Assessment saved successfully with ID:", insertedData.id)

      return { data: insertedData, error: null }
    } catch (error) {
      console.error("‚ùå AssessmentService: Save assessment failed:", error)
      let errorMessage = "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å"

      if (error instanceof Error) {
        if (error.message.includes("network") || error.message.includes("fetch")) {
          errorMessage = "‡∏õ‡∏±‡∏ç‡∏´‡∏≤‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏≠‡∏¥‡∏ô‡πÄ‡∏ó‡∏≠‡∏£‡πå‡πÄ‡∏ô‡πá‡∏ï"
        } else if (error.message.includes("authentication") || error.message.includes("unauthorized")) {
          errorMessage = "‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà‡∏£‡∏∞‡∏ö‡∏ö‡πÉ‡∏´‡∏°‡πà"
        } else {
          errorMessage = error.message
        }
      }

      return { data: null, error: errorMessage }
    }
  }

  static async getLatestAssessmentForUserAndCategory(
    supabaseClient: SupabaseClient,
    userId: string,
    categoryId: string,
  ): Promise<{ data: any; error: any }> {
    try {
      if (!supabaseClient) {
        throw new Error("Database connection not available")
      }

      console.log("üîç AssessmentService: Fetching latest assessment for user:", userId, "category:", categoryId)

      const { data, error } = await supabaseClient
        .from("assessments")
        .select("*")
        .eq("user_id", userId)
        .eq("category_id", categoryId)
        .order("completed_at", { ascending: false })
        .limit(1)
        .single()

      if (error && error.code !== "PGRST116") {
        console.error("‚ùå AssessmentService: Supabase fetch error:", error)
        throw error
      }

      if (!data) {
        console.log("‚ö†Ô∏è AssessmentService: No assessment found for user and category")
        return { data: null, error: null }
      }

      console.log("‚úÖ AssessmentService: Found latest assessment:", data.id)
      return { data, error: null }
    } catch (error) {
      console.error("‚ùå AssessmentService: Get latest assessment failed:", error)
      return { data: null, error: (error as Error).message || "Failed to retrieve latest assessment" }
    }
  }

  static async getAssessmentById(
    supabaseClient: SupabaseClient,
    assessmentId: string,
  ): Promise<{ data: any; error: any }> {
    try {
      if (!supabaseClient) {
        throw new Error("Database connection not available")
      }

      console.log("üîç AssessmentService: Fetching assessment by ID:", assessmentId)

      const { data, error } = await supabaseClient.from("assessments").select("*").eq("id", assessmentId).single()

      if (error) {
        console.error("‚ùå AssessmentService: Supabase fetch by ID error:", error)
        throw error
      }

      console.log("‚úÖ AssessmentService: Found assessment by ID:", data.id)
      return { data, error: null }
    } catch (error) {
      console.error("‚ùå AssessmentService: Get assessment by ID failed:", error)
      return { data: null, error: (error as Error).message || "Failed to retrieve assessment" }
    }
  }

  static async getUserAssessments(
    supabaseClient: SupabaseClient,
    userId: string,
  ): Promise<{ data: any[]; error: any }> {
    try {
      if (!supabaseClient) {
        throw new Error("Database connection not available")
      }

      const { data, error } = await supabaseClient
        .from("assessments")
        .select("*")
        .eq("user_id", userId)
        .order("completed_at", { ascending: false })

      if (error) throw error

      return { data: data || [], error: null }
    } catch (error) {
      return { data: [], error }
    }
  }

  static async getLatestUserAssessments(
    supabaseClient: SupabaseClient,
    userId: string,
  ): Promise<{ data: any[]; error: any }> {
    try {
      if (!supabaseClient) {
        throw new Error("Database connection not available")
      }

      const { data, error } = await supabaseClient
        .from("assessments")
        .select("*")
        .eq("user_id", userId)
        .order("completed_at", { ascending: false })

      if (error) throw error

      const latestByCategory = new Map()
      const allAssessments = data || []

      allAssessments.forEach((assessment) => {
        const categoryId = assessment.category_id
        const currentLatest = latestByCategory.get(categoryId)

        if (!currentLatest || new Date(assessment.completed_at) > new Date(currentLatest.completed_at)) {
          latestByCategory.set(categoryId, assessment)
        }
      })

      const latestAssessments = Array.from(latestByCategory.values())
      return { data: latestAssessments, error: null }
    } catch (error) {
      return { data: [], error }
    }
  }

  private static calculateBasicAssessmentResult(answers: AssessmentAnswer[]): AssessmentResult {
    const category = AssessmentService.getCategory("basic")
    if (!category) throw new Error("Basic category not found")

    const totalScore = answers.reduce((sum, answer) => sum + answer.score, 0)
    const maxScore = answers.length * 5
    const percentage = Math.round((totalScore / maxScore) * 100)

    let riskLevel: "low" | "medium" | "high" | "very-high"
    if (percentage < 30) riskLevel = "low"
    else if (percentage < 50) riskLevel = "medium"
    else if (percentage < 70) riskLevel = "high"
    else riskLevel = "very-high"

    const riskFactors: string[] = []
    const recommendations: string[] = []

    answers.forEach((answer) => {
      const question = category.questions.find((q) => q.id === answer.questionId)
      if (!question) return

      if (question.id === "basic-3" || question.id === "basic-4") {
        const weightAnswer = answers.find((a) => a.questionId === "basic-3")
        const heightAnswer = answers.find((a) => a.questionId === "basic-4")

        if (weightAnswer && heightAnswer) {
          const weight = Number(weightAnswer.answer)
          const height = Number(heightAnswer.answer) / 100
          const bmi = weight / (height * height)

          if (bmi < 18.5) {
            riskFactors.push("‡∏ô‡πâ‡∏≥‡∏´‡∏ô‡∏±‡∏Å‡∏ï‡πà‡∏≥‡∏Å‡∏ß‡πà‡∏≤‡πÄ‡∏Å‡∏ì‡∏ë‡πå")
            recommendations.push("‡∏Ñ‡∏ß‡∏£‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ô‡πâ‡∏≥‡∏´‡∏ô‡∏±‡∏Å‡πÉ‡∏´‡πâ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡πÄ‡∏Å‡∏ì‡∏ë‡πå‡∏õ‡∏Å‡∏ï‡∏¥")
          } else if (bmi >= 25) {
            riskFactors.push("‡∏ô‡πâ‡∏≥‡∏´‡∏ô‡∏±‡∏Å‡πÄ‡∏Å‡∏¥‡∏ô‡∏´‡∏£‡∏∑‡∏≠‡πÇ‡∏£‡∏Ñ‡∏≠‡πâ‡∏ß‡∏ô")
            recommendations.push("‡∏Ñ‡∏ß‡∏£‡∏•‡∏î‡∏ô‡πâ‡∏≥‡∏´‡∏ô‡∏±‡∏Å‡πÅ‡∏•‡∏∞‡∏≠‡∏≠‡∏Å‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏Å‡∏≤‡∏¢‡∏™‡∏°‡πà‡∏≥‡πÄ‡∏™‡∏°‡∏≠")
          }
        }
      }

      if (question.id === "basic-6" && Array.isArray(answer.answer)) {
        const diseases = answer.answer as string[]
        diseases.forEach((disease) => {
          if (disease !== "‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÇ‡∏£‡∏Ñ‡∏õ‡∏£‡∏∞‡∏à‡∏≥‡∏ï‡∏±‡∏ß") {
            riskFactors.push(disease)
            if (disease === "‡πÄ‡∏ö‡∏≤‡∏´‡∏ß‡∏≤‡∏ô") {
              recommendations.push("‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡∏£‡∏∞‡∏î‡∏±‡∏ö‡∏ô‡πâ‡∏≥‡∏ï‡∏≤‡∏•‡πÉ‡∏ô‡πÄ‡∏•‡∏∑‡∏≠‡∏î‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏™‡∏°‡πà‡∏≥‡πÄ‡∏™‡∏°‡∏≠")
            } else if (disease === "‡∏Ñ‡∏ß‡∏≤‡∏°‡∏î‡∏±‡∏ô‡πÇ‡∏•‡∏´‡∏¥‡∏ï‡∏™‡∏π‡∏á") {
              recommendations.push("‡∏ï‡∏£‡∏ß‡∏à‡∏ß‡∏±‡∏î‡∏Ñ‡∏ß‡∏≤‡∏°‡∏î‡∏±‡∏ô‡πÇ‡∏•‡∏´‡∏¥‡∏ï‡πÄ‡∏õ‡πá‡∏ô‡∏õ‡∏£‡∏∞‡∏à‡∏≥")
            }
          }
        })
      }

      if (question.id === "basic-7" && Array.isArray(answer.answer)) {
        const allergies = answer.answer as string[]
        allergies.forEach((allergy) => {
          if (allergy !== "‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡πÅ‡∏û‡πâ") {
            riskFactors.push(`‡πÅ‡∏û‡πâ: ${allergy}`)
          }
        })
      }
    })

    if (riskFactors.length === 0) {
      recommendations.push("‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏∏‡∏Ç‡∏†‡∏≤‡∏û‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡πÄ‡∏Å‡∏ì‡∏ë‡πå‡∏õ‡∏Å‡∏ï‡∏¥")
      recommendations.push("‡∏Ñ‡∏ß‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏∏‡∏Ç‡∏†‡∏≤‡∏û‡∏õ‡∏£‡∏∞‡∏à‡∏≥‡∏õ‡∏µ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏°‡∏™‡∏∏‡∏Ç‡∏†‡∏≤‡∏û")
    } else {
      recommendations.push("‡∏Ñ‡∏ß‡∏£‡∏õ‡∏£‡∏∂‡∏Å‡∏©‡∏≤‡πÅ‡∏û‡∏ó‡∏¢‡πå‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏£‡∏±‡∏ö‡∏Ñ‡∏≥‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ö‡∏∏‡∏Ñ‡∏Ñ‡∏•")
      recommendations.push("‡∏ô‡∏≥‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ô‡∏µ‡πâ‡πÑ‡∏õ‡πÅ‡∏™‡∏î‡∏á‡πÅ‡∏û‡∏ó‡∏¢‡πå‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÑ‡∏õ‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏£‡∏±‡∏Å‡∏©‡∏≤")
    }

    return {
      categoryId: "basic",
      totalScore,
      maxScore,
      percentage,
      riskLevel,
      riskFactors,
      recommendations,
    }
  }

  static async testConnection(supabaseClient: SupabaseClient): Promise<boolean> {
    try {
      if (!supabaseClient) return false

      const { data, error } = await supabaseClient.from("profiles").select("id").limit(1)
      return !error
    } catch (error) {
      console.error("AssessmentService.testConnection: Failed to test connection:", error)
      return false
    }
  }

  static cleanup() {
    this.activeRequests.forEach((controller, key) => {
      controller.abort()
    })
    this.activeRequests.clear()
  }
}
